# 阶段 0：Docker + 基础网络（Mac M1 跟练版）

## 0.0 先把 Docker 环境准备好（Mac M1）

你有两条路：

### 方案 A：Docker Desktop（最省事）

按官方文档安装即可（选择 Apple silicon 版本）。

安装完成后验证：

```
docker version
docker run --rm hello-world
```

你应该看到 `Hello from Docker!` 之类的输出。

------

### 方案 B：不装 Desktop，用 Colima（更轻量）

Colima 官方仓库给了 Homebrew 安装方式。

```
brew install colima docker docker-compose
colima start
docker run --rm hello-world
```

> 两种方案都可以；后面练习命令完全一致。



### **效果如下：**

![1](/Users/chensibin/workplace/company/dotnetcode/GitHub/Study-Notes/Ops/Kubernetes 学习路线/images/1.png)

---

## 0.1 目标知识点 1：镜像 vs 容器（以及为什么 K8s 关心镜像）

### 概念解释

- **镜像（Image）**：应用的“安装包 + 运行环境”，是只读模板
- **容器（Container）**：镜像跑起来后的“实例”（会有运行时状态）
- **Registry**：镜像仓库（Docker Hub/私有仓库）

K8s 里 Deployment/Pod 本质就是：**声明要跑哪个镜像、跑多少个实例**。

### 跟练：拉镜像 + 启动容器 + 删除容器

```bash
docker pull nginx:1.27
docker run --name mynginx -d -p 8080:80 nginx:1.27
curl -I http://localhost:8080
docker rm -f mynginx
```

**验证点：**

- **`curl -I` 能看到 `HTTP/1.1 200 OK`**
- **删除后再 curl 会失败（说明容器确实停掉了）**

### **效果：**

![2](/Users/chensibin/workplace/company/dotnetcode/GitHub/Study-Notes/Ops/Kubernetes 学习路线/images/2.png)

---

## 0.2 目标知识点 2：会写 Dockerfile（build 出你自己的镜像）

### 概念解释（你需要掌握的 Dockerfile 指令）

- `FROM`：基础镜像（相当于运行环境起点）
- `WORKDIR`：工作目录
- `COPY`：复制代码/文件进镜像
- `RUN`：构建阶段执行命令（装依赖等）
- `ENV`：环境变量
- `EXPOSE`：声明容器要用的端口（偏“文档化”）
- `CMD`/`ENTRYPOINT`：容器启动时默认执行命令

[Docker 官方也推荐遵循一些构建最佳实践（例如使用合适的基础镜像、利用缓存、多阶段构建等）。](https://docs.docker.com/build/building/best-practices/?utm_source=chatgpt.com#create-reusable-stages)

------

### 跟练：做一个最小 Web 服务镜像（Flask 示例）

#### 1）创建项目目录

```bash
mkdir -p k8s-prep-stage0/hello-web
cd k8s-prep-stage0/hello-web
```

#### 2）创建 `app.py`

```python
from flask import Flask
import os

app = Flask(__name__)

@app.get("/")
def home():
    return {
        "service": "hello-web",
        "version": os.getenv("VERSION", "v1"),
        "env": os.getenv("APP_ENV", "dev")
    }

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8080)
```

#### 3）创建 `requirements.txt`

```
flask==3.0.3
```

#### 4）创建 `Dockerfile`

```dockerfile
# 1) 指定基础镜像：
#    - 这里使用官方 Python 3\.12 的精简版 Debian 镜像（slim）
#    - 优点：体积更小；适合生产镜像
#    - 注意：slim 往往缺少编译依赖/系统库，某些需要编译的三方包可能要额外 apt-get 安装依赖
FROM python:3.12-slim

# 2) 设置容器内的工作目录（后续命令的默认执行目录）：
#    - 若目录不存在会自动创建
#    - 后续的 COPY/RUN/CMD 等若使用相对路径，都会以 /app 为基准
WORKDIR /app

# 3) 只拷贝依赖清单到镜像中：
#    - 先单独 COPY requirements\.txt 的目的：利用 Docker 分层缓存
#    - 当代码改动但 requirements\.txt 未变时，依赖安装层可复用，构建更快
COPY requirements.txt .

# 4) 安装 Python 依赖：
#    - 使用 pip 从 requirements\.txt 安装
#    - --no-cache-dir 表示不保留 pip 下载缓存，减小最终镜像体积
#    - 这一层通常最耗时，但也最适合被缓存
RUN pip install --no-cache-dir -r requirements.txt

# 5) 拷贝应用源码到工作目录：
#    - 把宿主机（构建上下文）里的 app\.py 拷贝到镜像 /app/app\.py
#    - 若你的项目有更多源码文件，通常会改为 COPY \. . 或分目录 COPY
COPY app.py .

# 6) 设置环境变量（运行时可被覆盖）：
#    - ENV 写入镜像默认环境变量
#    - 运行容器时可用 -e APP_ENV=prod 覆盖
ENV APP_ENV=dev
ENV VERSION=v1

# 7) 声明容器“将要监听”的端口：
#    - EXPOSE 仅是文档化/元数据，不会自动把端口映射到宿主机
#    - 真正映射需 docker run -p 8080:8080
EXPOSE 8080

# 8) 设置容器启动时的默认命令：
#    - 使用 exec 形式（JSON 数组）避免经过 shell，信号转发更可靠
#    - 容器启动时相当于执行：python app\.py
CMD ["python", "app.py"]
```

#### 5）build 镜像

```bash
docker build -t hello-web:v1 .
```

#### 6）run 容器并访问

```bash
docker run --rm -d --name hello-web -p 8080:8080 hello-web:v1
curl http://localhost:8080
```

你应该看到类似：

```json
{"service":"hello-web","version":"v1","env":"dev"}
```

#### 7）看日志（后面排障非常重要）

```bash
docker logs -f hello-web
# Ctrl+C 退出 follow
```

#### 8）停止容器

```bash
docker stop hello-web
```

### **效果：**

![3](/Users/chensibin/workplace/company/dotnetcode/GitHub/Study-Notes/Ops/Kubernetes 学习路线/images/3.png)

------

## 0.3 目标知识点 3：环境变量注入（K8s ConfigMap/Secret 的前身）

### 概念解释

同一个镜像，在不同环境（dev/staging/prod）跑起来时：

- **不建议把环境差异写死在代码/镜像里**
- 应该通过环境变量/配置文件注入

K8s 的 ConfigMap/Secret 就是在更大规模上干这件事。

### 跟练：运行时覆盖 ENV

```bash
docker run --rm -d --name hello-web \
  -e APP_ENV=prod -e VERSION=v2 \
  -p 8080:8080 hello-web:v1

curl http://localhost:8080
docker rm -f hello-web
```

你应该看到 version/env 变成 `v2/prod`。

**效果：**![4](/Users/chensibin/workplace/company/dotnetcode/GitHub/Study-Notes/Ops/Kubernetes 学习路线/images/4.png)

---

## 0.4 目标知识点 4：端口映射与“服务对外暴露”的本质

## （K8s Service/Ingress 的前身）

### 概念解释

- 容器内部监听端口（例：8080）
- 宿主机访问需要把宿主端口映射到容器端口：`-p 宿主:容器`
- 你映射的是**宿主机端口**，不是“打开容器防火墙”

### 跟练：故意映射错端口，体会错误

```bash
docker run --rm -d --name hello-web -p 8081:8080 hello-web:v1
curl http://localhost:8080   # 失败
curl http://localhost:8081   # 成功
docker rm -f hello-web
```

**效果：**

![5](/Users/chensibin/workplace/company/dotnetcode/GitHub/Study-Notes/Ops/Kubernetes 学习路线/images/5.png)

---

## 0.5 目标知识点 5：容器网络与 DNS（K8s Service 发现机制的前身）

### 概念解释

Docker 可以创建自定义网络（bridge）：

- 同一个网络中的容器可以通过 **容器名*** 当 **DNS** 互相访问
- 这对“微服务互调”与“反向代理”非常关键

K8s 中就是 Service DNS（例如 `api.default.svc.cluster.local`）的思路。

### 跟练：创建网络 + 两个服务互相访问（用 curl 容器）

#### 1）创建网络

```bash
docker network create demo-net
```

#### 2）启动 hello-web（加入 demo-net）

```bash
docker run --rm -d --name hello-web --network demo-net hello-web:v1
```

#### 3）启动一个 curl 容器去访问 hello-web（用容器名）

```bash
docker run --rm --network demo-net curlimages/curl:8.5.0 \
curl -sS http://hello-web:8080
```

你应该能拿到 JSON。

#### 4）清理

```bash
docker rm -f hello-web
docker network rm demo-net
```

**效果：**

![6](/Users/chensibin/workplace/company/dotnetcode/GitHub/Study-Notes/Ops/Kubernetes 学习路线/images/6.png)

---

## 0.6 目标知识点 6：反向代理（K8s Ingress 的前身）

### 概念解释

反向代理（Reverse Proxy）做的事：

- 接收外部请求
- 根据规则转发给内部服务（不同路径/域名 → 不同后端）
- 聚合入口、统一 TLS、统一路由治理

Nginx 官方也把“作为代理服务器转发请求”作为典型用途。

### 跟练：用 Nginx 做路径路由（/api → hello-web）

我们将做一个结构：

- 外部访问：`http://localhost:8088/api`
- Nginx 转发到：`hello-web:8080`

#### 1）准备 nginx 配置

```bash
mkdir -p nginx
cat > nginx/nginx.conf << 'EOF'
events {}

http {
  server {
    listen 80;

    location /api {
      proxy_pass http://hello-web:8080/;
    }

    location / {
      return 200 "ok - nginx is running\n";
    }
  }
}
EOF
```

#### 2）创建网络并启动 hello-web

```bash
docker network create demo-net

docker run --rm -d --name hello-web --network demo-net \
  -e VERSION=v1 -e APP_ENV=dev \
  hello-web:v1
```

#### 3）启动 nginx（同网络，映射宿主 8088）

```bash
docker run --rm -d --name demo-nginx --network demo-net \
  -p 8088:80 \
  -v "$(pwd)/nginx/nginx.conf:/etc/nginx/nginx.conf:ro" \
  nginx:1.27
```

#### 4）验证

```bash
curl http://localhost:8088/
curl http://localhost:8088/api
```

你应看到：

- `/` 返回 `ok - nginx is running`
- `/api` 返回 hello-web 的 JSON

#### 5）清理

```
docker rm -f demo-nginx hello-web
docker network rm demo-net
```

**效果：**

![7](/Users/chensibin/workplace/company/dotnetcode/GitHub/Study-Notes/Ops/Kubernetes 学习路线/images/7.png)

---

## 0.7 目标知识点 7：数据持久化（Volume）（K8s PVC 的前身）

### 概念解释

容器是“可替换的”，容器删除后内部文件也会消失。
 要持久化就需要：

- **挂载宿主目录**（bind mount）
- 或 **docker volume**

K8s 里的 PV/PVC 就是在集群上把“卷”标准化。

### 跟练：把容器生成文件写到宿主机目录

```bash
mkdir -p data
docker run --rm -it \
  -v "$(pwd)/data:/data" \
  busybox:1.36 sh -c 'date > /data/now.txt && cat /data/now.txt'
cat data/now.txt
```

你会看到宿主机 `data/now.txt` 里有时间戳。

---

## 0.8（可选加分）目标知识点 8：多架构与 M1 的坑（ARM64 vs AMD64）

### 解释

M1 默认是 `arm64`，大多数官方镜像是多架构没问题；但少数镜像只有 `amd64`，这时要：

- 用 `--platform=linux/amd64` 运行（可能更慢）

跟练（只要知道怎么做即可）：

```bash
docker run --rm --platform=linux/amd64 alpine:3.20 uname -m
docker run --rm alpine:3.20 uname -m
```

---

阶段 0 最终验收（你做完应达到什么水平）

你如果能独立完成下面清单，就说明阶段 0 过关：

-  能写 Dockerfile，把一个 Web 服务 build 成镜像并运行
-  能用 `-p` 做端口映射，并解释“宿主端口 vs 容器端口”
-  能用 `-e` 注入环境变量，让同镜像跑出不同配置
-  能创建 docker network，让容器用“名字当 DNS”互访
-  能用 Nginx 做反向代理（路径路由到后端服务）
-  能用 volume 把数据写到宿主机，容器删了数据仍在
-  遇到问题会用：`docker logs` / `docker ps` / `docker exec` 排查